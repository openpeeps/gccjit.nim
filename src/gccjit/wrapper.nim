# Nim bindings for libgccjit. Autogenerated from the C header file
# using c2nim tool > https://github.com/nim-lang/c2nim
#
# (c) 2025 George Lemon | GPLv3 License
#          Made by Humans from OpenPeeps
#          https://github.com/openpeeps/libdatachannel-nim

{.passL:"-L/usr/local/lib -lgccjit".}

const ext =
  when defined(linux):
    "so"
  elif defined(windows):
    "dll"
  else:
    "dylib"

{.push, header:"<libgccjit.h>", dynlib: "libgccjit." & ext.}
type
  gcc_jit_context* {.bycopy.} = object
    ## A gcc_jit_context encapsulates the state of a compilation.
    ## You can set up options on it, and add types, functions and code, using
    ## the API below.
    ## 
    ## Invoking gcc_jit_context_compile on it gives you a gcc_jit_result *
    ## (or NULL), representing in-memory machine code.
    ## 
    ## You can call gcc_jit_context_compile repeatedly on one context, giving
    ## multiple independent results.
    ## 
    ## Similarly, you can call gcc_jit_context_compile_to_file on a context
    ## to compile to disk.
    ## 
    ## Eventually you can call gcc_jit_context_release to clean up the
    ## context; any in-memory results created from it are still usable, and
    ## should be cleaned up via gcc_jit_result_release.
  gcc_jit_result* {.bycopy.} = object
  gcc_jit_object* {.bycopy.} = object
  gcc_jit_location* {.bycopy.} = object
  gcc_jit_type* {.bycopy.} = object
  gcc_jit_field* {.bycopy.} = object
  gcc_jit_struct* {.bycopy.} = object
  gcc_jit_function_type* {.bycopy.} = object
  gcc_jit_vector_type* {.bycopy.} = object
  gcc_jit_function* {.bycopy.} = object
  gcc_jit_block* {.bycopy.} = object
    ## A gcc_jit_block encapsulates a "basic block" of statements within a
    ## function (i.e. with one entry point and one exit point).
    ## Every block within a function must be terminated with a conditional,
    ## a branch, or a return.
    ## 
    ## The blocks within a function form a directed graph.
    ## The entrypoint to the function is the first block created within it
    ## 
    ## All of the blocks in a function must be reachable via some path from
    ## the first block.
    ## 
    ## It's OK to have more than one "return" from a function (i.e. multiple
    ## blocks that terminate by returning).
  gcc_jit_rvalue* {.bycopy.} = object
    ## A gcc_jit_rvalue is an expression within your code, with some type.
  gcc_jit_lvalue* {.bycopy.} = object
    ## A gcc_jit_lvalue is a storage location within your code (e.g. a
    ## variable, a parameter, etc).  It is also an rvalue; use
    ## gcc_jit_lvalue_as_rvalue to cast.

  gcc_jit_param* {.bycopy.} = object
    ## A gcc_jit_param is a function parameter, used when creating a
    ## gcc_jit_function.  It is also a gcc_jit_lvalue (and thus also an
    ## rvalue); use gcc_jit_param_as_lvalue to convert.
  gcc_jit_case* {.bycopy.} = object
    ## A gcc_jit_case is for use when building multiway branches via
    ## gcc_jit_block_end_with_switch and represents a range of integer
    ## values (or an individual integer value) together with an associated
    ## destination block.
  gcc_jit_extended_asm* {.bycopy.} = object
    ## A gcc_jit_extended_asm represents an assembly language statement,
    ## analogous to an extended "asm" statement in GCC's C front-end: a series
    ## of low-level instructions inside a function that convert inputs to
    ## outputs.

  gcc_jit_timer* {.bycopy.} = object
    ## A gcc_jit_timer encapsulates a timer used to measure the time taken
    ## by a function or block of code.


##  Acquire a JIT-compilation context.

proc gcc_jit_context_acquire*(): ptr gcc_jit_context
##  Release the context.  After this call, it's no longer valid to use
##    the ctxt.

proc gcc_jit_context_release*(ctxt: ptr gcc_jit_context)
##  Options present in the initial release of libgccjit.
##    These were handled using enums.
##  Options taking string values.

type
  gcc_jit_str_option* = enum ##  The name of the program, for use as a prefix when printing error
                          ##      messages to stderr.  If NULL, or default, "libgccjit.so" is used.
    GCC_JIT_STR_OPTION_PROGNAME, GCC_JIT_NUM_STR_OPTIONS


##  Options taking int values.

type
  gcc_jit_int_option* = enum ##  How much to optimize the code.
                          ##      Valid values are 0-3, corresponding to GCC's command-line options
                          ##      -O0 through -O3.
                          ##
                          ##      The default value is 0 (unoptimized).
    GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL, GCC_JIT_NUM_INT_OPTIONS


##  Options taking boolean values.
##    These all default to "false".

type
  gcc_jit_bool_option* = enum ##  If true, gcc_jit_context_compile will attempt to do the right
                           ##      thing so that if you attach a debugger to the process, it will
                           ##      be able to inspect variables and step through your code.
                           ##
                           ##      Note that you can't step through code unless you set up source
                           ##      location information for the code (by creating and passing in
                           ##      gcc_jit_location instances).
    GCC_JIT_BOOL_OPTION_DEBUGINFO,
      ##  If true, gcc_jit_context_compile will dump its initial "tree"
      ##      representation of your code to stderr (before any
      ##      optimizations).
    GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE
      ##  If true, gcc_jit_context_compile will dump the "gimple"
      ##      representation of your code to stderr, before any optimizations
      ##      are performed.  The dump resembles C code.
    GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE
      ##  If true, gcc_jit_context_compile will dump the final
      ##      generated code to stderr, in the form of assembly language.
    GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,
      ##  If true, gcc_jit_context_compile will print information to stderr
      ##      on the actions it is performing, followed by a profile showing
      ##      the time taken and memory usage of each phase.
      ##
    GCC_JIT_BOOL_OPTION_DUMP_SUMMARY, ##  If true, gcc_jit_context_compile will dump copious
                                     ##      amount of information on what it's doing to various
                                     ##      files within a temporary directory.  Use
                                     ##      GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES (see below) to
                                     ##      see the results.  The files are intended to be human-readable,
                                     ##      but the exact files and their formats are subject to change.
                                     ##
    GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING, ##  If true, libgccjit will aggressively run its garbage collector, to
                                        ##      shake out bugs (greatly slowing down the compile).  This is likely
                                        ##      to only be of interest to developers *of* the library.  It is
                                        ##      used when running the selftest suite.
    GCC_JIT_BOOL_OPTION_SELFCHECK_GC, ##  If true, gcc_jit_context_release will not clean up
                                     ##      intermediate files written to the filesystem, and will display
                                     ##      their location on stderr.
    GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES, GCC_JIT_NUM_BOOL_OPTIONS


##  Set a string option on the given context.
##
##    The context takes a copy of the string, so the
##    (const char *) buffer is not needed anymore after the call
##    returns.

proc gcc_jit_context_set_str_option*(ctxt: ptr gcc_jit_context;
                                    opt: gcc_jit_str_option; value: cstring)
##  Set an int option on the given context.

proc gcc_jit_context_set_int_option*(ctxt: ptr gcc_jit_context;
                                    opt: gcc_jit_int_option; value: cint)
##  Set a boolean option on the given context.
##
##    Zero is "false" (the default), non-zero is "true".

proc gcc_jit_context_set_bool_option*(ctxt: ptr gcc_jit_context;
                                     opt: gcc_jit_bool_option; value: cint)
##  Options added after the initial release of libgccjit.
##    These are handled by providing an entrypoint per option,
##    rather than by extending the enum gcc_jit_*_option,
##    so that client code that use these new options can be identified
##    from binary metadata.
##  By default, libgccjit will issue an error about unreachable blocks
##    within a function.
##
##    This option can be used to disable that error.
##
##    This entrypoint was added in LIBGCCJIT_ABI_2; you can test for
##    its presence using
##      #ifdef LIBGCCJIT_HAVE_gcc_jit_context_set_bool_allow_unreachable_blocks
##

proc gcc_jit_context_set_bool_allow_unreachable_blocks*(
    ctxt: ptr gcc_jit_context; bool_value: cint)
##  Pre-canned feature macro to indicate the presence of
##    gcc_jit_context_set_bool_allow_unreachable_blocks.  This can be
##    tested for with #ifdef.

##  By default, libgccjit will print errors to stderr.
##
##    This option can be used to disable the printing.
##
##    This entrypoint was added in LIBGCCJIT_ABI_23; you can test for
##    its presence using
##      #ifdef LIBGCCJIT_HAVE_gcc_jit_context_set_bool_print_errors_to_stderr
##

proc gcc_jit_context_set_bool_print_errors_to_stderr*(ctxt: ptr gcc_jit_context;
    enabled: cint)
##  Pre-canned feature macro to indicate the presence of
##    gcc_jit_context_set_bool_print_errors_to_stderr.  This can be
##    tested for with #ifdef.

##  Implementation detail:
##    libgccjit internally generates assembler, and uses "driver" code
##    for converting it to other formats (e.g. shared libraries).
##
##    By default, libgccjit will use an embedded copy of the driver
##    code.
##
##    This option can be used to instead invoke an external driver executable
##    as a subprocess.
##
##    This entrypoint was added in LIBGCCJIT_ABI_5; you can test for
##    its presence using
##      #ifdef LIBGCCJIT_HAVE_gcc_jit_context_set_bool_use_external_driver
##

proc gcc_jit_context_set_bool_use_external_driver*(ctxt: ptr gcc_jit_context;
    bool_value: cint)
##  Pre-canned feature macro to indicate the presence of
##    gcc_jit_context_set_bool_use_external_driver.  This can be
##    tested for with #ifdef.

##  Add an arbitrary gcc command-line option to the context.
##    The context takes a copy of the string, so the
##    (const char *) optname is not needed anymore after the call
##    returns.
##
##    Note that only some options are likely to be meaningful; there is no
##    "frontend" within libgccjit, so typically only those affecting
##    optimization and code-generation are likely to be useful.
##
##    This entrypoint was added in LIBGCCJIT_ABI_1; you can test for
##    its presence using
##    #ifdef LIBGCCJIT_HAVE_gcc_jit_context_add_command_line_option
##

proc gcc_jit_context_add_command_line_option*(ctxt: ptr gcc_jit_context;
    optname: cstring)
##  Pre-canned feature-test macro for detecting the presence of
##    gcc_jit_context_add_command_line_option within libgccjit.h.

##  Add an arbitrary gcc driver option to the context.
##    The context takes a copy of the string, so the
##    (const char *) optname is not needed anymore after the call
##    returns.
##
##    Note that only some options are likely to be meaningful; there is no
##    "frontend" within libgccjit, so typically only those affecting
##    assembler and linker are likely to be useful.
##
##    This entrypoint was added in LIBGCCJIT_ABI_11; you can test for
##    its presence using
##    #ifdef LIBGCCJIT_HAVE_gcc_jit_context_add_driver_option
##

proc gcc_jit_context_add_driver_option*(ctxt: ptr gcc_jit_context; optname: cstring)
##  Pre-canned feature-test macro for detecting the presence of
##    gcc_jit_context_add_driver_option within libgccjit.h.

##  Compile the context to in-memory machine code.
##
##    This can be called more that once on a given context,
##    although any errors that occur will block further compilation.

proc gcc_jit_context_compile*(ctxt: ptr gcc_jit_context): ptr gcc_jit_result
## Kinds of ahead-of-time compilation, for use with
## gcc_jit_context_compile_to_file.

type
  gcc_jit_output_kind* = enum   ##  Compile the context to an assembler file.
    GCC_JIT_OUTPUT_KIND_ASSEMBLER, ##  Compile the context to an object file.
    GCC_JIT_OUTPUT_KIND_OBJECT_FILE, ##  Compile the context to a dynamic library.
    GCC_JIT_OUTPUT_KIND_DYNAMIC_LIBRARY, ##  Compile the context to an executable.
    GCC_JIT_OUTPUT_KIND_EXECUTABLE


##  Compile the context to a file of the given kind.
##
##    This can be called more that once on a given context,
##    although any errors that occur will block further compilation.

proc gcc_jit_context_compile_to_file*(ctxt: ptr gcc_jit_context;
                                     output_kind: gcc_jit_output_kind;
                                     output_path: cstring)
##  To help with debugging: dump a C-like representation to the given path,
##    describing what's been set up on the context.
##
##    If "update_locations" is true, then also set up gcc_jit_location
##    information throughout the context, pointing at the dump file as if it
##    were a source file.  This may be of use in conjunction with
##    GCC_JIT_BOOL_OPTION_DEBUGINFO to allow stepping through the code in a
##    debugger.

proc gcc_jit_context_dump_to_file*(ctxt: ptr gcc_jit_context; path: cstring;
                                  update_locations: cint)
##  To help with debugging; enable ongoing logging of the context's
##    activity to the given FILE *.
##
##    The caller remains responsible for closing "logfile".
##
##    Params "flags" and "verbosity" are reserved for future use, and
##    must both be 0 for now.

proc gcc_jit_context_set_logfile*(ctxt: ptr gcc_jit_context; logfile: ptr FILE;
                                 flags: cint; verbosity: cint)
##  To be called after any API call, this gives the first error message
##    that occurred on the context.
##
##    The returned string is valid for the rest of the lifetime of the
##    context.
##
##    If no errors occurred, this will be NULL.

proc gcc_jit_context_get_first_error*(ctxt: ptr gcc_jit_context): cstring
##  To be called after any API call, this gives the last error message
##    that occurred on the context.
##
##    If no errors occurred, this will be NULL.
##
##    If non-NULL, the returned string is only guaranteed to be valid until
##    the next call to libgccjit relating to this context.

proc gcc_jit_context_get_last_error*(ctxt: ptr gcc_jit_context): cstring
##  Locate a given function within the built machine code.
##    This will need to be cast to a function pointer of the
##    correct type before it can be called.

proc gcc_jit_result_get_code*(result: ptr gcc_jit_result; funcname: cstring): pointer
##  Locate a given global within the built machine code.
##    It must have been created using GCC_JIT_GLOBAL_EXPORTED.
##    This is a ptr to the global, so e.g. for an int this is an int *.

proc gcc_jit_result_get_global*(result: ptr gcc_jit_result; name: cstring): pointer
##  Once we're done with the code, this unloads the built .so file.
##    This cleans up the result; after calling this, it's no longer
##    valid to use the result.

proc gcc_jit_result_release*(result: ptr gcc_jit_result)
## ********************************************************************
##  Functions for creating "contextual" objects.
##
##  All objects created by these functions share the lifetime of the context
##  they are created within, and are automatically cleaned up for you when
##  you call gcc_jit_context_release on the context.
##
##  Note that this means you can't use references to them after you've
##  released their context.
##
##  All (const char *) string arguments passed to these functions are
##  copied, so you don't need to keep them around.
##
##  You create code by adding a sequence of statements to blocks.
## ********************************************************************
## ********************************************************************
##  The base class of "contextual" object.
## ********************************************************************
##  Which context is "obj" within?

proc gcc_jit_object_get_context*(obj: ptr gcc_jit_object): ptr gcc_jit_context
##  Get a human-readable description of this object.
##    The string buffer is created the first time this is called on a given
##    object, and persists until the object's context is released.

proc gcc_jit_object_get_debug_string*(obj: ptr gcc_jit_object): cstring
## ********************************************************************
##  Debugging information.
## ********************************************************************
##  Creating source code locations for use by the debugger.
##    Line and column numbers are 1-based.

proc gcc_jit_context_new_location*(ctxt: ptr gcc_jit_context; filename: cstring;
                                  line: cint; column: cint): ptr gcc_jit_location
##  Upcasting from location to object.

proc gcc_jit_location_as_object*(loc: ptr gcc_jit_location): ptr gcc_jit_object
## ********************************************************************
##  Types.
## ********************************************************************
##  Upcasting from type to object.

proc gcc_jit_type_as_object*(`type`: ptr gcc_jit_type): ptr gcc_jit_object
##  Access to specific types.

type
  gcc_jit_types* = enum         ##  C's "void" type.
    GCC_JIT_TYPE_VOID,        ##  "void *".
    GCC_JIT_TYPE_VOID_PTR, ##  C++'s bool type; also C99's "_Bool" type, aka "bool" if using
                          ##      stdbool.h.
    GCC_JIT_TYPE_BOOL, ##  Various integer types.
                      ##  C's "char" (of some signedness) and the variants where the
                      ##      signedness is specified.
    GCC_JIT_TYPE_CHAR,
    GCC_JIT_TYPE_SIGNED_CHAR,
    GCC_JIT_TYPE_UNSIGNED_CHAR, ##  C's "short" and "unsigned short".
    GCC_JIT_TYPE_SHORT,       ##  signed
    GCC_JIT_TYPE_UNSIGNED_SHORT, ##  C's "int" and "unsigned int".
    GCC_JIT_TYPE_INT,         ##  signed
    GCC_JIT_TYPE_UNSIGNED_INT, ##  C's "long" and "unsigned long".
    GCC_JIT_TYPE_LONG,        ##  signed
    GCC_JIT_TYPE_UNSIGNED_LONG, ##  C99's "long long" and "unsigned long long".
    GCC_JIT_TYPE_LONG_LONG,   ##  signed
    GCC_JIT_TYPE_UNSIGNED_LONG_LONG, ##  Floating-point types
    GCC_JIT_TYPE_FLOAT, GCC_JIT_TYPE_DOUBLE, GCC_JIT_TYPE_LONG_DOUBLE, ##  C type: (const char *).
    GCC_JIT_TYPE_CONST_CHAR_PTR, ##  The C "size_t" type.
    GCC_JIT_TYPE_SIZE_T,      ##  C type: (FILE *)
    GCC_JIT_TYPE_FILE_PTR,    ##  Complex numbers.
    GCC_JIT_TYPE_COMPLEX_FLOAT, GCC_JIT_TYPE_COMPLEX_DOUBLE, GCC_JIT_TYPE_COMPLEX_LONG_DOUBLE, ##  Sized integer types.
    GCC_JIT_TYPE_UINT8_T, GCC_JIT_TYPE_UINT16_T, GCC_JIT_TYPE_UINT32_T,
    GCC_JIT_TYPE_UINT64_T, GCC_JIT_TYPE_UINT128_T, GCC_JIT_TYPE_INT8_T,
    GCC_JIT_TYPE_INT16_T, GCC_JIT_TYPE_INT32_T, GCC_JIT_TYPE_INT64_T,
    GCC_JIT_TYPE_INT128_T


proc gcc_jit_context_get_type*(ctxt: ptr gcc_jit_context; `type`: gcc_jit_types): ptr gcc_jit_type
##  Get the integer type of the given size and signedness.

proc gcc_jit_context_get_int_type*(ctxt: ptr gcc_jit_context; num_bytes: cint;
                                  is_signed: cint): ptr gcc_jit_type
##  Constructing new types.
##  Given type "T", get type "T*".

proc gcc_jit_type_get_pointer*(`type`: ptr gcc_jit_type): ptr gcc_jit_type
##  Given type "T", get type "const T".

proc gcc_jit_type_get_const*(`type`: ptr gcc_jit_type): ptr gcc_jit_type
##  Given type "T", get type "volatile T".

proc gcc_jit_type_get_volatile*(`type`: ptr gcc_jit_type): ptr gcc_jit_type
##  Given type "T", get type "restrict T".
##    This API entrypoint was added in LIBGCCJIT_ABI_25; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_gcc_jit_type_get_restrict

proc gcc_jit_type_get_restrict*(`type`: ptr gcc_jit_type): ptr gcc_jit_type
##  Given types LTYPE and RTYPE, return non-zero if they are compatible.
##    This API entrypoint was added in LIBGCCJIT_ABI_20; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_SIZED_INTEGERS

proc gcc_jit_compatible_types*(ltype: ptr gcc_jit_type; rtype: ptr gcc_jit_type): cint
##  Given type "T", get its size.
##    This API entrypoint was added in LIBGCCJIT_ABI_20; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_SIZED_INTEGERS

proc gcc_jit_type_get_size*(`type`: ptr gcc_jit_type): csize_t
##  Given type "T", get type "T[N]" (for a constant N).

proc gcc_jit_context_new_array_type*(ctxt: ptr gcc_jit_context;
                                    loc: ptr gcc_jit_location;
                                    element_type: ptr gcc_jit_type;
                                    num_elements: cint): ptr gcc_jit_type
##  Struct-handling.
##  Create a field, for use within a struct or union.

proc gcc_jit_context_new_field*(ctxt: ptr gcc_jit_context;
                               loc: ptr gcc_jit_location; `type`: ptr gcc_jit_type;
                               name: cstring): ptr gcc_jit_field
##  Create a bit field, for use within a struct or union.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_12; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_gcc_jit_context_new_bitfield
##

proc gcc_jit_context_new_bitfield*(ctxt: ptr gcc_jit_context;
                                  loc: ptr gcc_jit_location;
                                  `type`: ptr gcc_jit_type; width: cint;
                                  name: cstring): ptr gcc_jit_field
##  Upcasting from field to object.

proc gcc_jit_field_as_object*(field: ptr gcc_jit_field): ptr gcc_jit_object
##  Create a struct type from an array of fields.

proc gcc_jit_context_new_struct_type*(ctxt: ptr gcc_jit_context;
                                     loc: ptr gcc_jit_location; name: cstring;
                                     num_fields: cint;
                                     fields: ptr ptr gcc_jit_field): ptr gcc_jit_struct
##  Create an opaque struct type.

proc gcc_jit_context_new_opaque_struct*(ctxt: ptr gcc_jit_context;
                                       loc: ptr gcc_jit_location; name: cstring): ptr gcc_jit_struct
##  Upcast a struct to a type.

proc gcc_jit_struct_as_type*(struct_type: ptr gcc_jit_struct): ptr gcc_jit_type
##  Populating the fields of a formerly-opaque struct type.
##    This can only be called once on a given struct type.

proc gcc_jit_struct_set_fields*(struct_type: ptr gcc_jit_struct;
                               loc: ptr gcc_jit_location; num_fields: cint;
                               fields: ptr ptr gcc_jit_field)
##  Get a field by index.

proc gcc_jit_struct_get_field*(struct_type: ptr gcc_jit_struct; index: csize_t): ptr gcc_jit_field
##  Get the number of fields.

proc gcc_jit_struct_get_field_count*(struct_type: ptr gcc_jit_struct): csize_t
##  Unions work similarly to structs.

proc gcc_jit_context_new_union_type*(ctxt: ptr gcc_jit_context;
                                    loc: ptr gcc_jit_location; name: cstring;
                                    num_fields: cint;
                                    fields: ptr ptr gcc_jit_field): ptr gcc_jit_type
##  Function pointers.

proc gcc_jit_context_new_function_ptr_type*(ctxt: ptr gcc_jit_context;
    loc: ptr gcc_jit_location; return_type: ptr gcc_jit_type; num_params: cint;
    param_types: ptr ptr gcc_jit_type; is_variadic: cint): ptr gcc_jit_type
## ********************************************************************
##  Constructing functions.
## ********************************************************************
##  Create a function param.

proc gcc_jit_context_new_param*(ctxt: ptr gcc_jit_context;
                               loc: ptr gcc_jit_location; `type`: ptr gcc_jit_type;
                               name: cstring): ptr gcc_jit_param
##  Upcasting from param to object.

proc gcc_jit_param_as_object*(param: ptr gcc_jit_param): ptr gcc_jit_object
##  Upcasting from param to lvalue.

proc gcc_jit_param_as_lvalue*(param: ptr gcc_jit_param): ptr gcc_jit_lvalue
##  Upcasting from param to rvalue.

proc gcc_jit_param_as_rvalue*(param: ptr gcc_jit_param): ptr gcc_jit_rvalue
##  Kinds of function.

type
  gcc_jit_function_kind* = enum ##  Function is defined by the client code and visible
                             ##      by name outside of the JIT.
    GCC_JIT_FUNCTION_EXPORTED, ##  Function is defined by the client code, but is invisible
                              ##      outside of the JIT.  Analogous to a "static" function.
    GCC_JIT_FUNCTION_INTERNAL, ##  Function is not defined by the client code; we're merely
                              ##      referring to it.  Analogous to using an "extern" function from a
                              ##      header file.
    GCC_JIT_FUNCTION_IMPORTED, ##  Function is only ever inlined into other functions, and is
                              ##      invisible outside of the JIT.
                              ##
                              ##      Analogous to prefixing with "inline" and adding
                              ##      __attribute__((always_inline)).
                              ##
                              ##      Inlining will only occur when the optimization level is
                              ##      above 0; when optimization is off, this is essentially the
                              ##      same as GCC_JIT_FUNCTION_INTERNAL.
    GCC_JIT_FUNCTION_ALWAYS_INLINE


##  Thread local storage model.

type
  gcc_jit_tls_model* = enum
    GCC_JIT_TLS_MODEL_NONE, GCC_JIT_TLS_MODEL_GLOBAL_DYNAMIC,
    GCC_JIT_TLS_MODEL_LOCAL_DYNAMIC, GCC_JIT_TLS_MODEL_INITIAL_EXEC,
    GCC_JIT_TLS_MODEL_LOCAL_EXEC


##  Create a function.

proc gcc_jit_context_new_function*(ctxt: ptr gcc_jit_context;
                                  loc: ptr gcc_jit_location;
                                  kind: gcc_jit_function_kind;
                                  return_type: ptr gcc_jit_type; name: cstring;
                                  num_params: cint; params: ptr ptr gcc_jit_param;
                                  is_variadic: cint): ptr gcc_jit_function
##  Create a reference to a builtin function (sometimes called
##    intrinsic functions).

proc gcc_jit_context_get_builtin_function*(ctxt: ptr gcc_jit_context; name: cstring): ptr gcc_jit_function
##  Upcasting from function to object.

proc gcc_jit_function_as_object*(`func`: ptr gcc_jit_function): ptr gcc_jit_object
##  Get a specific param of a function by index.

proc gcc_jit_function_get_param*(`func`: ptr gcc_jit_function; index: cint): ptr gcc_jit_param
##  Emit the function in graphviz format.

proc gcc_jit_function_dump_to_dot*(`func`: ptr gcc_jit_function; path: cstring)
##  Create a block.
##
##    The name can be NULL, or you can give it a meaningful name, which
##    may show up in dumps of the internal representation, and in error
##    messages.

proc gcc_jit_function_new_block*(`func`: ptr gcc_jit_function; name: cstring): ptr gcc_jit_block
##  Upcasting from block to object.

proc gcc_jit_block_as_object*(`block`: ptr gcc_jit_block): ptr gcc_jit_object
##  Which function is this block within?

proc gcc_jit_block_get_function*(`block`: ptr gcc_jit_block): ptr gcc_jit_function
## ********************************************************************
##  lvalues, rvalues and expressions.
## ********************************************************************

type
  gcc_jit_global_kind* = enum   ##  Global is defined by the client code and visible
                           ##      by name outside of this JIT context via gcc_jit_result_get_global.
    GCC_JIT_GLOBAL_EXPORTED, ##  Global is defined by the client code, but is invisible
                            ##      outside of this JIT context.  Analogous to a "static" global.
    GCC_JIT_GLOBAL_INTERNAL, ##  Global is not defined by the client code; we're merely
                            ##      referring to it.  Analogous to using an "extern" global from a
                            ##      header file.
    GCC_JIT_GLOBAL_IMPORTED


proc gcc_jit_context_new_global*(ctxt: ptr gcc_jit_context;
                                loc: ptr gcc_jit_location;
                                kind: gcc_jit_global_kind;
                                `type`: ptr gcc_jit_type; name: cstring): ptr gcc_jit_lvalue
##  Create a constructor for a struct as an rvalue.
##
##    Returns NULL on error.  The two parameter arrays are copied and
##    do not have to outlive the context.
##
##    `type` specifies what the constructor will build and has to be
##    a struct.
##
##    `num_values` specifies the number of elements in `values`.
##
##    `fields` need to have the same length as `values`, or be NULL.
##
##    If `fields` is null, the values are applied in definition order.
##
##    Otherwise, each field in `fields` specifies which field in the struct to
##    set to the corresponding value in `values`.  `fields` and `values`
##    are paired by index.
##
##    Each value has to have the same unqualified type as the field
##    it is applied to.
##
##    A NULL value element  in `values` is a shorthand for zero initialization
##    of the corresponding field.
##
##    The fields in `fields` have to be in definition order, but there
##    can be gaps.  Any field in the struct that is not specified in
##    `fields` will be zeroed.
##
##    The fields in `fields` need to be the same objects that were used
##    to create the struct.
##
##    If `num_values` is 0, the array parameters will be
##    ignored and zero initialization will be used.
##
##    The constructor rvalue can be used for assignment to locals.
##    It can be used to initialize global variables with
##    gcc_jit_global_set_initializer_rvalue.  It can also be used as a
##    temporary value for function calls and return values.
##
##    The constructor can contain nested constructors.
##
##    This entrypoint was added in LIBGCCJIT_ABI_19; you can test for its
##    presence using:
##    #ifdef LIBGCCJIT_HAVE_CTORS
##

proc gcc_jit_context_new_struct_constructor*(ctxt: ptr gcc_jit_context;
    loc: ptr gcc_jit_location; `type`: ptr gcc_jit_type; num_values: csize_t;
    fields: ptr ptr gcc_jit_field; values: ptr ptr gcc_jit_rvalue): ptr gcc_jit_rvalue
##  Create a constructor for a union as an rvalue.
##
##    Returns NULL on error.
##
##    `type` specifies what the constructor will build and has to be
##    an union.
##
##    `field` specifies which field to set.  If it is NULL, the first
##    field in the union will be set.  `field` need to be the same
##    object that were used to create the union.
##
##    `value` specifies what value to set the corresponding field to.
##    If `value` is NULL, zero initialization will be used.
##
##    Each value has to have the same unqualified type as the field
##    it is applied to.
##
##    `field` need to be the same objects that were used
##    to create the union.
##
##    The constructor rvalue can be used for assignment to locals.
##    It can be used to initialize global variables with
##    gcc_jit_global_set_initializer_rvalue.  It can also be used as a
##    temporary value for function calls and return values.
##
##    The constructor can contain nested constructors.
##
##    This entrypoint was added in LIBGCCJIT_ABI_19; you can test for its
##    presence using:
##    #ifdef LIBGCCJIT_HAVE_CTORS
##

proc gcc_jit_context_new_union_constructor*(ctxt: ptr gcc_jit_context;
    loc: ptr gcc_jit_location; `type`: ptr gcc_jit_type; field: ptr gcc_jit_field;
    value: ptr gcc_jit_rvalue): ptr gcc_jit_rvalue
##  Create a constructor for an array as an rvalue.
##
##    Returns NULL on error.  `values` are copied and
##    do not have to outlive the context.
##
##    `type` specifies what the constructor will build and has to be
##    an array.
##
##    `num_values` specifies the number of elements in `values` and
##    it can't have more elements than the array type.
##
##    Each value in `values` sets the corresponding value in the array.
##    If the array type itself has more elements than `values`, the
##    left-over elements will be zeroed.
##
##    Each value in `values` need to be the same unqualified type as the
##    array type's element type.
##
##    If `num_values` is 0, the `values` parameter will be
##    ignored and zero initialization will be used.
##
##    Note that a string literal rvalue can't be used to construct a char
##    array.  It needs one rvalue for each char.
##
##    This entrypoint was added in LIBGCCJIT_ABI_19; you can test for its
##    presence using:
##    #ifdef LIBGCCJIT_HAVE_CTORS
##

proc gcc_jit_context_new_array_constructor*(ctxt: ptr gcc_jit_context;
    loc: ptr gcc_jit_location; `type`: ptr gcc_jit_type; num_values: csize_t;
    values: ptr ptr gcc_jit_rvalue): ptr gcc_jit_rvalue
##  Set the initial value of a global of any type with an rvalue.
##
##    The rvalue needs to be a constant expression, e.g. no function calls.
##
##    The global can't have the 'kind' GCC_JIT_GLOBAL_IMPORTED.
##
##    Use together with gcc_jit_context_new_constructor () to
##    initialize structs, unions and arrays.
##
##    On success, returns the 'global' parameter unchanged.  Otherwise, NULL.
##
##    'values' is copied and does not have to outlive the context.
##
##    This entrypoint was added in LIBGCCJIT_ABI_19; you can test for its
##    presence using:
##      #ifdef LIBGCCJIT_HAVE_CTORS
##

proc gcc_jit_global_set_initializer_rvalue*(global: ptr gcc_jit_lvalue;
    init_value: ptr gcc_jit_rvalue): ptr gcc_jit_lvalue
##  Set an initial value for a global, which must be an array of
##    integral type.  Return the global itself.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_14; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_gcc_jit_global_set_initializer
##

proc gcc_jit_global_set_initializer*(global: ptr gcc_jit_lvalue; blob: pointer;
                                    num_bytes: csize_t): ptr gcc_jit_lvalue
##  Upcasting.

proc gcc_jit_lvalue_as_object*(lvalue: ptr gcc_jit_lvalue): ptr gcc_jit_object
proc gcc_jit_lvalue_as_rvalue*(lvalue: ptr gcc_jit_lvalue): ptr gcc_jit_rvalue
proc gcc_jit_rvalue_as_object*(rvalue: ptr gcc_jit_rvalue): ptr gcc_jit_object
proc gcc_jit_rvalue_get_type*(rvalue: ptr gcc_jit_rvalue): ptr gcc_jit_type
##  Integer constants.

proc gcc_jit_context_new_rvalue_from_int*(ctxt: ptr gcc_jit_context;
    numeric_type: ptr gcc_jit_type; value: cint): ptr gcc_jit_rvalue
proc gcc_jit_context_new_rvalue_from_long*(ctxt: ptr gcc_jit_context;
    numeric_type: ptr gcc_jit_type; value: clong): ptr gcc_jit_rvalue
proc gcc_jit_context_zero*(ctxt: ptr gcc_jit_context; numeric_type: ptr gcc_jit_type): ptr gcc_jit_rvalue
proc gcc_jit_context_one*(ctxt: ptr gcc_jit_context; numeric_type: ptr gcc_jit_type): ptr gcc_jit_rvalue
##  Floating-point constants.

proc gcc_jit_context_new_rvalue_from_double*(ctxt: ptr gcc_jit_context;
    numeric_type: ptr gcc_jit_type; value: cdouble): ptr gcc_jit_rvalue
##  Pointers.

proc gcc_jit_context_new_rvalue_from_ptr*(ctxt: ptr gcc_jit_context;
    pointer_type: ptr gcc_jit_type; value: pointer): ptr gcc_jit_rvalue
proc gcc_jit_context_null*(ctxt: ptr gcc_jit_context; pointer_type: ptr gcc_jit_type): ptr gcc_jit_rvalue
##  Generates an rvalue that is equal to the size of type.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_27; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_gcc_jit_context_new_sizeof

proc gcc_jit_context_new_sizeof*(ctxt: ptr gcc_jit_context; `type`: ptr gcc_jit_type): ptr gcc_jit_rvalue
##  String literals.

proc gcc_jit_context_new_string_literal*(ctxt: ptr gcc_jit_context; value: cstring): ptr gcc_jit_rvalue
type
  gcc_jit_unary_op* = enum      ##  Negate an arithmetic value; analogous to:
                        ##        -(EXPR)
                        ##      in C.
    GCC_JIT_UNARY_OP_MINUS, ##  Bitwise negation of an integer value (one's complement); analogous
                           ##      to:
                           ##        ~(EXPR)
                           ##      in C.
    GCC_JIT_UNARY_OP_BITWISE_NEGATE, ##  Logical negation of an arithmetic or pointer value; analogous to:
                                    ##        !(EXPR)
                                    ##      in C.
    GCC_JIT_UNARY_OP_LOGICAL_NEGATE, ##  Absolute value of an arithmetic expression; analogous to:
                                    ##        abs (EXPR)
                                    ##      in C.
    GCC_JIT_UNARY_OP_ABS


proc gcc_jit_context_new_unary_op*(ctxt: ptr gcc_jit_context;
                                  loc: ptr gcc_jit_location; op: gcc_jit_unary_op;
                                  result_type: ptr gcc_jit_type;
                                  rvalue: ptr gcc_jit_rvalue): ptr gcc_jit_rvalue
type
  gcc_jit_binary_op* = enum     ##  Addition of arithmetic values; analogous to:
                         ##        (EXPR_A) + (EXPR_B)
                         ##      in C.
                         ##      For pointer addition, use gcc_jit_context_new_array_access.
    GCC_JIT_BINARY_OP_PLUS,   ##  Subtraction of arithmetic values; analogous to:
                           ##        (EXPR_A) - (EXPR_B)
                           ##      in C.
    GCC_JIT_BINARY_OP_MINUS, ##  Multiplication of a pair of arithmetic values; analogous to:
                            ##        (EXPR_A) * (EXPR_B)
                            ##      in C.
    GCC_JIT_BINARY_OP_MULT, ##  Quotient of division of arithmetic values; analogous to:
                           ##        (EXPR_A) / (EXPR_B)
                           ##      in C.
                           ##      The result type affects the kind of division: if the result type is
                           ##      integer-based, then the result is truncated towards zero, whereas
                           ##      a floating-point result type indicates floating-point division.
    GCC_JIT_BINARY_OP_DIVIDE, ##  Remainder of division of arithmetic values; analogous to:
                             ##        (EXPR_A) % (EXPR_B)
                             ##      in C.
    GCC_JIT_BINARY_OP_MODULO, ##  Bitwise AND; analogous to:
                             ##        (EXPR_A) & (EXPR_B)
                             ##      in C.
    GCC_JIT_BINARY_OP_BITWISE_AND, ##  Bitwise exclusive OR; analogous to:
                                  ##        (EXPR_A) ^ (EXPR_B)
                                  ##      in C.
    GCC_JIT_BINARY_OP_BITWISE_XOR, ##  Bitwise inclusive OR; analogous to:
                                  ##        (EXPR_A) | (EXPR_B)
                                  ##      in C.
    GCC_JIT_BINARY_OP_BITWISE_OR, ##  Logical AND; analogous to:
                                 ##        (EXPR_A) && (EXPR_B)
                                 ##      in C.
    GCC_JIT_BINARY_OP_LOGICAL_AND, ##  Logical OR; analogous to:
                                  ##        (EXPR_A) || (EXPR_B)
                                  ##      in C.
    GCC_JIT_BINARY_OP_LOGICAL_OR, ##  Left shift; analogous to:
                                 ##        (EXPR_A) << (EXPR_B)
                                 ##      in C.
    GCC_JIT_BINARY_OP_LSHIFT, ##  Right shift; analogous to:
                             ##        (EXPR_A) >> (EXPR_B)
                             ##      in C.
    GCC_JIT_BINARY_OP_RSHIFT


proc gcc_jit_context_new_binary_op*(ctxt: ptr gcc_jit_context;
                                   loc: ptr gcc_jit_location;
                                   op: gcc_jit_binary_op;
                                   result_type: ptr gcc_jit_type;
                                   a: ptr gcc_jit_rvalue; b: ptr gcc_jit_rvalue): ptr gcc_jit_rvalue
##  (Comparisons are treated as separate from "binary_op" to save
##    you having to specify the result_type).

type
  gcc_jit_comparison* = enum    ##  (EXPR_A) == (EXPR_B).
    GCC_JIT_COMPARISON_EQ,    ##  (EXPR_A) != (EXPR_B).
    GCC_JIT_COMPARISON_NE,    ##  (EXPR_A) < (EXPR_B).
    GCC_JIT_COMPARISON_LT,    ##  (EXPR_A) <=(EXPR_B).
    GCC_JIT_COMPARISON_LE,    ##  (EXPR_A) > (EXPR_B).
    GCC_JIT_COMPARISON_GT,    ##  (EXPR_A) >= (EXPR_B).
    GCC_JIT_COMPARISON_GE


proc gcc_jit_context_new_comparison*(ctxt: ptr gcc_jit_context;
                                    loc: ptr gcc_jit_location;
                                    op: gcc_jit_comparison; a: ptr gcc_jit_rvalue;
                                    b: ptr gcc_jit_rvalue): ptr gcc_jit_rvalue
##  Function calls.
##  Call of a specific function.

proc gcc_jit_context_new_call*(ctxt: ptr gcc_jit_context; loc: ptr gcc_jit_location;
                              `func`: ptr gcc_jit_function; numargs: cint;
                              args: ptr ptr gcc_jit_rvalue): ptr gcc_jit_rvalue
##  Call through a function pointer.

proc gcc_jit_context_new_call_through_ptr*(ctxt: ptr gcc_jit_context;
    loc: ptr gcc_jit_location; fn_ptr: ptr gcc_jit_rvalue; numargs: cint;
    args: UncheckedArray[ptr gcc_jit_rvalue]): ptr gcc_jit_rvalue
##  Type-coercion.
##
##    Currently only a limited set of conversions are possible:
##      int <-> float
##      int <-> bool

proc gcc_jit_context_new_cast*(ctxt: ptr gcc_jit_context; loc: ptr gcc_jit_location;
                              rvalue: ptr gcc_jit_rvalue; `type`: ptr gcc_jit_type): ptr gcc_jit_rvalue
##  Reinterpret a value as another type.
##
##    The types must be of the same size.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_21; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_gcc_jit_context_new_bitcast

proc gcc_jit_context_new_bitcast*(ctxt: ptr gcc_jit_context;
                                 loc: ptr gcc_jit_location;
                                 rvalue: ptr gcc_jit_rvalue;
                                 `type`: ptr gcc_jit_type): ptr gcc_jit_rvalue
##  Set the alignment of a variable.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_24; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_ALIGNMENT

proc gcc_jit_lvalue_set_alignment*(lvalue: ptr gcc_jit_lvalue; bytes: cuint)
##  Get the alignment of a variable.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_24; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_ALIGNMENT

proc gcc_jit_lvalue_get_alignment*(lvalue: ptr gcc_jit_lvalue): cuint
proc gcc_jit_context_new_array_access*(ctxt: ptr gcc_jit_context;
                                      loc: ptr gcc_jit_location;
                                      `ptr`: ptr gcc_jit_rvalue;
                                      index: ptr gcc_jit_rvalue): ptr gcc_jit_lvalue
##  Field access is provided separately for both lvalues and rvalues.
##  Accessing a field of an lvalue of struct type, analogous to:
##       (EXPR).field = ...;
##    in C.

proc gcc_jit_lvalue_access_field*(struct_or_union: ptr gcc_jit_lvalue;
                                 loc: ptr gcc_jit_location;
                                 field: ptr gcc_jit_field): ptr gcc_jit_lvalue
##  Accessing a field of an rvalue of struct type, analogous to:
##       (EXPR).field
##    in C.

proc gcc_jit_rvalue_access_field*(struct_or_union: ptr gcc_jit_rvalue;
                                 loc: ptr gcc_jit_location;
                                 field: ptr gcc_jit_field): ptr gcc_jit_rvalue
##  Accessing a field of an rvalue of pointer type, analogous to:
##       (EXPR)->field
##    in C, itself equivalent to (*EXPR).FIELD

proc gcc_jit_rvalue_dereference_field*(`ptr`: ptr gcc_jit_rvalue;
                                      loc: ptr gcc_jit_location;
                                      field: ptr gcc_jit_field): ptr gcc_jit_lvalue
##  Dereferencing a pointer; analogous to:
## (EXPR)
##

proc gcc_jit_rvalue_dereference*(rvalue: ptr gcc_jit_rvalue;
                                loc: ptr gcc_jit_location): ptr gcc_jit_lvalue
##  Taking the address of an lvalue; analogous to:
##      &(EXPR)
##    in C.

proc gcc_jit_lvalue_get_address*(lvalue: ptr gcc_jit_lvalue;
                                loc: ptr gcc_jit_location): ptr gcc_jit_rvalue
##  Set the thread-local storage model of a global variable
##
##    This API entrypoint was added in LIBGCCJIT_ABI_17; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_gcc_jit_lvalue_set_tls_model

proc gcc_jit_lvalue_set_tls_model*(lvalue: ptr gcc_jit_lvalue;
                                  model: gcc_jit_tls_model)
##  Set the link section of a global variable; analogous to:
##      __attribute__((section(".section_name")))
##    in C.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_18; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_gcc_jit_lvalue_set_link_section
##

proc gcc_jit_lvalue_set_link_section*(lvalue: ptr gcc_jit_lvalue;
                                     section_name: cstring)
##  Make this variable a register variable and set its register name.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_22; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_gcc_jit_lvalue_set_register_name
##

proc gcc_jit_lvalue_set_register_name*(lvalue: ptr gcc_jit_lvalue; reg_name: cstring)
proc gcc_jit_function_new_local*(`func`: ptr gcc_jit_function;
                                loc: ptr gcc_jit_location;
                                `type`: ptr gcc_jit_type; name: cstring): ptr gcc_jit_lvalue
## ********************************************************************
##  Statement-creation.
## ********************************************************************
##  Add evaluation of an rvalue, discarding the result
##    (e.g. a function call that "returns" void).
##
##    This is equivalent to this C code:
##
##      (void)expression;
##

proc gcc_jit_block_add_eval*(`block`: ptr gcc_jit_block; loc: ptr gcc_jit_location;
                            rvalue: ptr gcc_jit_rvalue)
##  Add evaluation of an rvalue, assigning the result to the given
##    lvalue.
##
##    This is roughly equivalent to this C code:
##
##      lvalue = rvalue;
##

proc gcc_jit_block_add_assignment*(`block`: ptr gcc_jit_block;
                                  loc: ptr gcc_jit_location;
                                  lvalue: ptr gcc_jit_lvalue;
                                  rvalue: ptr gcc_jit_rvalue)
##  Add evaluation of an rvalue, using the result to modify an
##    lvalue.
##
##    This is analogous to "+=" and friends:
##
##      lvalue += rvalue;
##      lvalue *= rvalue;
##      lvalue /= rvalue;
##    etc

proc gcc_jit_block_add_assignment_op*(`block`: ptr gcc_jit_block;
                                     loc: ptr gcc_jit_location;
                                     lvalue: ptr gcc_jit_lvalue;
                                     op: gcc_jit_binary_op;
                                     rvalue: ptr gcc_jit_rvalue)
##  Add a no-op textual comment to the internal representation of the
##    code.  It will be optimized away, but will be visible in the dumps
##    seen via
##      GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE
##    and
##      GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE,
##    and thus may be of use when debugging how your project's internal
##    representation gets converted to the libgccjit IR.

proc gcc_jit_block_add_comment*(`block`: ptr gcc_jit_block;
                               loc: ptr gcc_jit_location; text: cstring)
##  Terminate a block by adding evaluation of an rvalue, branching on the
##    result to the appropriate successor block.
##
##    This is roughly equivalent to this C code:
##
##      if (boolval)
##        goto on_true;
##      else
##        goto on_false;
##
##    block, boolval, on_true, and on_false must be non-NULL.

proc gcc_jit_block_end_with_conditional*(`block`: ptr gcc_jit_block;
                                        loc: ptr gcc_jit_location;
                                        boolval: ptr gcc_jit_rvalue;
                                        on_true: ptr gcc_jit_block;
                                        on_false: ptr gcc_jit_block)
##  Terminate a block by adding a jump to the given target block.
##
##    This is roughly equivalent to this C code:
##
##       goto target;
##

proc gcc_jit_block_end_with_jump*(`block`: ptr gcc_jit_block;
                                 loc: ptr gcc_jit_location;
                                 target: ptr gcc_jit_block)
##  Terminate a block by adding evaluation of an rvalue, returning the value.
##
##    This is roughly equivalent to this C code:
##
##       return expression;
##

proc gcc_jit_block_end_with_return*(`block`: ptr gcc_jit_block;
                                   loc: ptr gcc_jit_location;
                                   rvalue: ptr gcc_jit_rvalue)
##  Terminate a block by adding a valueless return, for use within a function
##    with "void" return type.
##
##    This is equivalent to this C code:
##
##       return;
##

proc gcc_jit_block_end_with_void_return*(`block`: ptr gcc_jit_block;
                                        loc: ptr gcc_jit_location)
##  Create a new gcc_jit_case instance for use in a switch statement.
##    min_value and max_value must be constants of integer type.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_3; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_SWITCH_STATEMENTS
##

proc gcc_jit_context_new_case*(ctxt: ptr gcc_jit_context;
                              min_value: ptr gcc_jit_rvalue;
                              max_value: ptr gcc_jit_rvalue;
                              dest_block: ptr gcc_jit_block): ptr gcc_jit_case
##  Upcasting from case to object.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_3; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_SWITCH_STATEMENTS
##

proc gcc_jit_case_as_object*(`case`: ptr gcc_jit_case): ptr gcc_jit_object
##  Terminate a block by adding evalation of an rvalue, then performing
##    a multiway branch.
##
##    This is roughly equivalent to this C code:
##
##      switch (expr)
##        {
##        default:
## 	 goto default_block;
##
##        case C0.min_value ... C0.max_value:
## 	 goto C0.dest_block;
##
##        case C1.min_value ... C1.max_value:
## 	 goto C1.dest_block;
##
##        ...etc...
##
##        case C[N - 1].min_value ... C[N - 1].max_value:
## 	 goto C[N - 1].dest_block;
##      }
##
##    block, expr, default_block and cases must all be non-NULL.
##
##    expr must be of the same integer type as all of the min_value
##    and max_value within the cases.
##
##    num_cases must be >= 0.
##
##    The ranges of the cases must not overlap (or have duplicate
##    values).
##
##    This API entrypoint was added in LIBGCCJIT_ABI_3; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_SWITCH_STATEMENTS
##

proc gcc_jit_block_end_with_switch*(`block`: ptr gcc_jit_block;
                                   loc: ptr gcc_jit_location;
                                   expr: ptr gcc_jit_rvalue;
                                   default_block: ptr gcc_jit_block;
                                   num_cases: cint; cases: ptr ptr gcc_jit_case)
##  Pre-canned feature macro to indicate the presence of
##    gcc_jit_block_end_with_switch, gcc_jit_case_as_object, and
##    gcc_jit_context_new_case.
##
##    This can be tested for with #ifdef.

## ********************************************************************
##  Nested contexts.
## ********************************************************************
##  Given an existing JIT context, create a child context.
##
##    The child inherits a copy of all option-settings from the parent.
##
##    The child can reference objects created within the parent, but not
##    vice-versa.
##
##    The lifetime of the child context must be bounded by that of the
##    parent: you should release a child context before releasing the parent
##    context.
##
##    If you use a function from a parent context within a child context,
##    you have to compile the parent context before you can compile the
##    child context, and the gcc_jit_result of the parent context must
##    outlive the gcc_jit_result of the child context.
##
##    This allows caching of shared initializations.  For example, you could
##    create types and declarations of global functions in a parent context
##    once within a process, and then create child contexts whenever a
##    function or loop becomes hot. Each such child context can be used for
##    JIT-compiling just one function or loop, but can reference types
##    and helper functions created within the parent context.
##
##    Contexts can be arbitrarily nested, provided the above rules are
##    followed, but it's probably not worth going above 2 or 3 levels, and
##    there will likely be a performance hit for such nesting.

proc gcc_jit_context_new_child_context*(parent_ctxt: ptr gcc_jit_context): ptr gcc_jit_context
## ********************************************************************
##  Implementation support.
## ********************************************************************
##  Write C source code into "path" that can be compiled into a
##    self-contained executable (i.e. with libgccjit as the only dependency).
##    The generated code will attempt to replay the API calls that have been
##    made into the given context.
##
##    This may be useful when debugging the library or client code, for
##    reducing a complicated recipe for reproducing a bug into a simpler
##    form.
##
##    Typically you need to supply the option "-Wno-unused-variable" when
##    compiling the generated file (since the result of each API call is
##    assigned to a unique variable within the generated C source, and not
##    all are necessarily then used).

proc gcc_jit_context_dump_reproducer_to_file*(ctxt: ptr gcc_jit_context;
    path: cstring)
##  Enable the dumping of a specific set of internal state from the
##    compilation, capturing the result in-memory as a buffer.
##
##    Parameter "dumpname" corresponds to the equivalent gcc command-line
##    option, without the "-fdump-" prefix.
##    For example, to get the equivalent of "-fdump-tree-vrp1", supply
##    "tree-vrp1".
##    The context directly stores the dumpname as a (const char *), so the
##    passed string must outlive the context.
##
##    gcc_jit_context_compile and gcc_jit_context_to_file
##    will capture the dump as a dynamically-allocated buffer, writing
##    it to ``*out_ptr``.
##
##    The caller becomes responsible for calling
##       free (*out_ptr)
##    each time that gcc_jit_context_compile or gcc_jit_context_to_file
##    are called.  *out_ptr will be written to, either with the address of a
##    buffer, or with NULL if an error occurred.
##
##    This API entrypoint is likely to be less stable than the others.
##    In particular, both the precise dumpnames, and the format and content
##    of the dumps are subject to change.
##
##    It exists primarily for writing the library's own test suite.

proc gcc_jit_context_enable_dump*(ctxt: ptr gcc_jit_context; dumpname: cstring;
                                 out_ptr: cstringArray)
## ********************************************************************
##  Timing support.
## ********************************************************************
##  The timing API was added in LIBGCCJIT_ABI_4; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_TIMING_API
##


##  Create a gcc_jit_timer instance, and start timing.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_TIMING_API
##

proc gcc_jit_timer_new*(): ptr gcc_jit_timer
##  Release a gcc_jit_timer instance.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_TIMING_API
##

proc gcc_jit_timer_release*(timer: ptr gcc_jit_timer)
##  Associate a gcc_jit_timer instance with a context.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_TIMING_API
##

proc gcc_jit_context_set_timer*(ctxt: ptr gcc_jit_context; timer: ptr gcc_jit_timer)
##  Get the timer associated with a context (if any).
##
##    This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_TIMING_API
##

proc gcc_jit_context_get_timer*(ctxt: ptr gcc_jit_context): ptr gcc_jit_timer
##  Push the given item onto the timing stack.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_TIMING_API
##

proc gcc_jit_timer_push*(timer: ptr gcc_jit_timer; item_name: cstring)
##  Pop the top item from the timing stack.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_TIMING_API
##

proc gcc_jit_timer_pop*(timer: ptr gcc_jit_timer; item_name: cstring)
##  Print timing information to the given stream about activity since
##    the timer was started.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_TIMING_API
##

proc gcc_jit_timer_print*(timer: ptr gcc_jit_timer; f_out: ptr FILE)
##  Mark/clear a call as needing tail-call optimization.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_6; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_gcc_jit_rvalue_set_bool_require_tail_call
##

proc gcc_jit_rvalue_set_bool_require_tail_call*(call: ptr gcc_jit_rvalue;
    require_tail_call: cint)
##  Given type "T", get type:
##
##      T __attribute__ ((aligned (ALIGNMENT_IN_BYTES)))
##
##    The alignment must be a power of two.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_7; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_gcc_jit_type_get_aligned
##

proc gcc_jit_type_get_aligned*(`type`: ptr gcc_jit_type; alignment_in_bytes: csize_t): ptr gcc_jit_type
##  Given type "T", get type:
##
##      T  __attribute__ ((vector_size (sizeof(T) * num_units))
##
##    T must be integral/floating point; num_units must be a power of two.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_8; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_gcc_jit_type_get_vector
##

proc gcc_jit_type_get_vector*(`type`: ptr gcc_jit_type; num_units: csize_t): ptr gcc_jit_type
##  Get the address of a function as an rvalue, of function pointer
##    type.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_9; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_gcc_jit_function_get_address
##

proc gcc_jit_function_get_address*(fn: ptr gcc_jit_function;
                                  loc: ptr gcc_jit_location): ptr gcc_jit_rvalue
##  Build a vector rvalue from an array of elements.
##
##    "vec_type" should be a vector type, created using gcc_jit_type_get_vector.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_10; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_gcc_jit_context_new_rvalue_from_vector
##

proc gcc_jit_context_new_rvalue_from_vector*(ctxt: ptr gcc_jit_context;
    loc: ptr gcc_jit_location; vec_type: ptr gcc_jit_type; num_elements: csize_t;
    elements: ptr ptr gcc_jit_rvalue): ptr gcc_jit_rvalue
##  Functions to retrieve libgccjit version.
##    Analogous to __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__ in C code.
##
##    These API entrypoints were added in LIBGCCJIT_ABI_13; you can test for their
##    presence using
##      #ifdef LIBGCCJIT_HAVE_gcc_jit_version
##

proc gcc_jit_version_major*(): cint
proc gcc_jit_version_minor*(): cint
proc gcc_jit_version_patchlevel*(): cint
## ********************************************************************
##  Asm support.
## ********************************************************************
##  Functions for adding inline assembler code, analogous to GCC's
##    "extended asm" syntax.
##
##    See https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html
##
##    These API entrypoints were added in LIBGCCJIT_ABI_15; you can test for their
##    presence using
##      #ifdef LIBGCCJIT_HAVE_ASM_STATEMENTS
##

##  Create a gcc_jit_extended_asm for an extended asm statement
##    with no control flow (i.e. without the goto qualifier).
##
##    The asm_template parameter  corresponds to the AssemblerTemplate
##    within C's extended asm syntax.  It must be non-NULL.

proc gcc_jit_block_add_extended_asm*(`block`: ptr gcc_jit_block;
                                    loc: ptr gcc_jit_location;
                                    asm_template: cstring): ptr gcc_jit_extended_asm
##  Create a gcc_jit_extended_asm for an extended asm statement
##    that may perform jumps, and use it to terminate the given block.
##    This is equivalent to the "goto" qualifier in C's extended asm
##    syntax.

proc gcc_jit_block_end_with_extended_asm_goto*(`block`: ptr gcc_jit_block;
    loc: ptr gcc_jit_location; asm_template: cstring; num_goto_blocks: cint;
    goto_blocks: ptr ptr gcc_jit_block; fallthrough_block: ptr gcc_jit_block): ptr gcc_jit_extended_asm
##  Upcasting from extended asm to object.

proc gcc_jit_extended_asm_as_object*(ext_asm: ptr gcc_jit_extended_asm): ptr gcc_jit_object
##  Set whether the gcc_jit_extended_asm has side-effects, equivalent to
##    the "volatile" qualifier in C's extended asm syntax.

proc gcc_jit_extended_asm_set_volatile_flag*(ext_asm: ptr gcc_jit_extended_asm;
    flag: cint)
##  Set the equivalent of the "inline" qualifier in C's extended asm
##    syntax.

proc gcc_jit_extended_asm_set_inline_flag*(ext_asm: ptr gcc_jit_extended_asm;
    flag: cint)
##  Add an output operand to the extended asm statement.
##    "asm_symbolic_name" can be NULL.
##    "constraint" and "dest" must be non-NULL.
##    This function can't be called on an "asm goto" as such instructions
##    can't have outputs

proc gcc_jit_extended_asm_add_output_operand*(ext_asm: ptr gcc_jit_extended_asm;
    asm_symbolic_name: cstring; constraint: cstring; dest: ptr gcc_jit_lvalue)
##  Add an input operand to the extended asm statement.
##    "asm_symbolic_name" can be NULL.
##    "constraint" and "src" must be non-NULL.

proc gcc_jit_extended_asm_add_input_operand*(ext_asm: ptr gcc_jit_extended_asm;
    asm_symbolic_name: cstring; constraint: cstring; src: ptr gcc_jit_rvalue)
##  Add "victim" to the list of registers clobbered by the extended
##    asm statement.  It must be non-NULL.

proc gcc_jit_extended_asm_add_clobber*(ext_asm: ptr gcc_jit_extended_asm;
                                      victim: cstring)
##  Add "asm_stmts", a set of top-level asm statements, analogous to
##    those created by GCC's "basic" asm syntax in C at file scope.

proc gcc_jit_context_add_top_level_asm*(ctxt: ptr gcc_jit_context;
                                       loc: ptr gcc_jit_location;
                                       asm_stmts: cstring)
##  Reflection functions to get the number of parameters, return type of
##    a function and whether a type is a bool from the C API.
##
##    This API entrypoint was added in LIBGCCJIT_ABI_16; you can test for its
##    presence using
##      #ifdef LIBGCCJIT_HAVE_REFLECTION
##
##  Get the return type of a function.

proc gcc_jit_function_get_return_type*(`func`: ptr gcc_jit_function): ptr gcc_jit_type
##  Get the number of params of a function.

proc gcc_jit_function_get_param_count*(`func`: ptr gcc_jit_function): csize_t
##  Get the element type of an array type or NULL if it's not an array.

proc gcc_jit_type_dyncast_array*(`type`: ptr gcc_jit_type): ptr gcc_jit_type
##  Return non-zero if the type is a bool.

proc gcc_jit_type_is_bool*(`type`: ptr gcc_jit_type): cint
##  Return the function type if it is one or NULL.

proc gcc_jit_type_dyncast_function_ptr_type*(`type`: ptr gcc_jit_type): ptr gcc_jit_function_type
##  Given a function type, return its return type.

proc gcc_jit_function_type_get_return_type*(
    function_type: ptr gcc_jit_function_type): ptr gcc_jit_type
##  Given a function type, return its number of parameters.

proc gcc_jit_function_type_get_param_count*(
    function_type: ptr gcc_jit_function_type): csize_t
##  Given a function type, return the type of the specified parameter.

proc gcc_jit_function_type_get_param_type*(
    function_type: ptr gcc_jit_function_type; index: csize_t): ptr gcc_jit_type
##  Return non-zero if the type is an integral.

proc gcc_jit_type_is_integral*(`type`: ptr gcc_jit_type): cint
##  Return the type pointed by the pointer type or NULL if it's not a
##  pointer.

proc gcc_jit_type_is_pointer*(`type`: ptr gcc_jit_type): ptr gcc_jit_type
##  Given a type, return a dynamic cast to a vector type or NULL.

proc gcc_jit_type_dyncast_vector*(`type`: ptr gcc_jit_type): ptr gcc_jit_vector_type
##  Given a type, return a dynamic cast to a struct type or NULL.

proc gcc_jit_type_is_struct*(`type`: ptr gcc_jit_type): ptr gcc_jit_struct
##  Given a vector type, return the number of units it contains.

proc gcc_jit_vector_type_get_num_units*(vector_type: ptr gcc_jit_vector_type): csize_t
##  Given a vector type, return the type of its elements.

proc gcc_jit_vector_type_get_element_type*(vector_type: ptr gcc_jit_vector_type): ptr gcc_jit_type
##  Given a type, return the unqualified type, removing "const", "volatile"
##  and alignment qualifiers.

proc gcc_jit_type_unqualified*(`type`: ptr gcc_jit_type): ptr gcc_jit_type
##  Function attributes.

type
  gcc_jit_fn_attribute* = enum
    GCC_JIT_FN_ATTRIBUTE_ALIAS, GCC_JIT_FN_ATTRIBUTE_ALWAYS_INLINE,
    GCC_JIT_FN_ATTRIBUTE_INLINE, GCC_JIT_FN_ATTRIBUTE_NOINLINE,
    GCC_JIT_FN_ATTRIBUTE_TARGET, GCC_JIT_FN_ATTRIBUTE_USED,
    GCC_JIT_FN_ATTRIBUTE_VISIBILITY, GCC_JIT_FN_ATTRIBUTE_COLD,
    GCC_JIT_FN_ATTRIBUTE_RETURNS_TWICE, GCC_JIT_FN_ATTRIBUTE_PURE,
    GCC_JIT_FN_ATTRIBUTE_CONST, GCC_JIT_FN_ATTRIBUTE_WEAK, GCC_JIT_FN_ATTRIBUTE_NONNULL, ##  Maximum value of this enum, should always be last.
    GCC_JIT_FN_ATTRIBUTE_MAX


##  Add an attribute to a function.

proc gcc_jit_function_add_attribute*(`func`: ptr gcc_jit_function;
                                    attribute: gcc_jit_fn_attribute)
proc gcc_jit_function_add_string_attribute*(`func`: ptr gcc_jit_function;
    attribute: gcc_jit_fn_attribute; value: cstring)
proc gcc_jit_function_add_integer_array_attribute*(`func`: ptr gcc_jit_function;
    attribute: gcc_jit_fn_attribute; value: ptr cint; length: csize_t)
##  Variable attributes.

type
  gcc_jit_variable_attribute* = enum
    GCC_JIT_VARIABLE_ATTRIBUTE_VISIBILITY, ##  Maximum value of this enum, should always be last.
    GCC_JIT_VARIABLE_ATTRIBUTE_MAX


##  Add a string attribute to a variable.

proc gcc_jit_lvalue_add_string_attribute*(variable: ptr gcc_jit_lvalue;
    attribute: gcc_jit_variable_attribute; value: cstring)

{.pop.}
